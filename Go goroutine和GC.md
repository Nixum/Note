---
title: Go Goroutine和GC
description: go 协程、调度、GC相关原理
date: 2021-03-22
lastmod: 2021-05-15
categories: ["Go"]
tags: ["Goroutine", "Go GC"]
---

[TOC]

# Runtime

* 不同于Java，Go没有虚拟机，很多东西比如自动GC、对操作系统和CPU相关操作都变成了函数，写在runtime包里。
* Runtime提供了go代码运行时所需要的基础设施，如协程调度、内存管理、GC、map、channel、string等内置类型的实现、对操作系统和CPU相关操作进行封装。
* 诸如go、new、make、->、<-等关键字都被编译器编译成runtime包里的函数
* build成可执行文件时，Runtime会和用户代码一起进行打包。

# pprof

* pprof提供应用运行的过程中分析当前应用的各项指标来辅助进行性能优化以及问题排查功能，提供以下功能
  
| 类型         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| allocs       | 查询内存分配情况，所有对象的内存分配，在堆（Heap）分配的时候，记录一下调用堆栈。默认情况下，是每 1000 次分配，取样一次，这个数值可以改变。栈(Stack)分配 由于会随时释放，因此不会被内存分析所记录。由于内存分析是取样方式，并且也因为其记录的是分配内存，而不是使用内存。开启后会对runtime产生压力，通过runtime.MemProfileRate设置采样的内存比例，默认大小是512kb。 |
| blocks       | 查询阻塞操作情况，类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。阻塞分析对分析程序并发瓶颈非常有帮助，阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞性能分析是特殊的分析工具，在排除 CPU 和内存瓶颈前，不应该用它来分析。 |
| cmdline      | 应用启动命令及参数                                           |
| goroutine    | 当前所有协程的堆栈信息，开启时会STW                          |
| heap         | 堆上内存使用情况采样信息，活跃对象的内存分配                 |
| mutex        | 锁持有的堆栈，次数(采样)的信息                               |
| profile      | CPU占用情况采样，启动后会对runtime产生压力，runtime每10ms会STW，记录当前运行的 goroutine 的调用堆栈及相关数据 |
| threadcreate | 系统线程创建情况的采样信息，不会STW                          |
| trace        | 程序运行跟踪信息                                             |

* `go tool pprof -http=:8080 profile文件名`，打开web终端，左上角view里就有各种视图

* 关于火焰图

  Y轴表示调用栈，每一层都是一个函数，调用栈越深火焰就越高，最底部是正在执行的函数，上面是它的父函数；
  
  X轴表示这个函数的抽样数，如果一个函数在X轴占的越宽，代表抽样数越高，执行CPU的时间越长，注意，X轴不代表时间,而是所有的调用栈合并后，按字母顺序排列的；
  
  火焰图就是看顶层的哪个函数占据的宽度最大。只要有"平顶"（plateaus），就表示该函数可能存在性能问题。

# Goroutine

## 基本

* GPM模型 - M：N调度模型

  模型分类：

  * N：1 即 N个协程绑定1个线程

    优点：协程在用户态线程即可完成切换，由协程调度器调度，不涉及内核态，无需CPU调度，轻量快速；

    缺点：无法使用多核加速，一旦某协程阻塞，会导致线程阻塞，此时并行变成串行；

  * 1：1 即 1个协程绑定1个线程

    优点：解决N：1模型的缺点；

    缺点：调度均有协程调度器和CPU调度，代价较大，无法并行；

  * M：N 即 M个协程绑定N个线程，由协程调度器调度，线程在内核态通过CPU抢占式调用，协程在用户态通过协作式调度

* 一般线程会占有1Mb以上的内存空间，每次对线程进行切换时会消耗较多内存，恢复寄存器中的内容还需要向操作系统申请或销毁对应的资源，每一次上下文切换都需要消耗~1us左右的时间，而Go调度器对goroutine的上下文切换为~0.2us，减少了80%的额外开销。

* 协程本质是一个数据结构，封装了要运行的函数和运行的进度，交由go调度器进行调度，不断切换的过程。由go调度器决定协程是运行，还是切换出调度队列(阻塞)，去执行其他满足条件的协程。

  go的调度器在用户态实现调度，调度的是一种名叫协程的执行流结构体，也有需要保存和恢复上下文的函数，运行队列。

  协程同步造成的阻塞，只是调度器切换到别的协程去执行了，线程本身并不阻塞。

  抢占：在协程中，要等到一个协程主动让出CPU才能执行下一个协程

* Go的调度器通过**使用与CPU数量相等的线程**减少线程频繁切换的内存开销，同时**在每一个线程上执行额外开销更低的Goroutine**来降低操作系统和软件的负载。

* 1.2~1.3版本使用**基于协作的抢占式调度器**（通过编译器在函数调用时插入抢占式检查指令，比如栈扩容检查，在函数调用时检查当前goroutine是否发起抢占式请求），但gouroutine可能会因为垃圾回收和循环时间太长占用资源导致没有让出CPU甚至让程序暂停；

  从1.14版本开始使用**基于信号的抢占式调度**，会给需要处理的函数绑上signhandler，处理SIGURG信号，比如垃圾回收在扫描栈时会触发抢占式调度，sysmon是其中一种实现；

  之所以要使用信号抢占式的，是因为如果是goroutine主动让出CPU资源才能触发调度，可能会导致某个goroutine长时间占用线程，造成其他goroutine饿死；另外，垃圾回收需要暂停整个程序，在STW时，整个程序无法工作。

## 早期调度模型-MG模型

![goroutine early schedule](https://github.com/Nixum/Java-Note/raw/master/picture/go早期调度模型.png)

线程M想要处理协程G，都必须访问全局队列GRQ，当多个M访问同一资源时需要加锁保证并发安全，因此M对G的创建，销毁，调度都需要上锁，造成激烈的锁竞争，导致性能较差。

另外，当M0执行G0，但G0又产生了G1，此时为了继续执行G0，需要将G1移给M1，造成较差的局部性，因为一般情况下这两个G是有一定的关联性的，如果放在不同的M会增加系统开销；CPU在多个M之间切换也增加了系统开销。

为了解决早期调度器模型的缺点，采用了GMP模型。

## 调度器的GPM模型

goroutine完全运行在用户态，借鉴M：N线程映射关系，采用GPM模型管理goroutine。

* G：即goroutine，代码中的`go func{}`，代表一个待执行的任务

  * 一个G最多占有CPU 10ms，防止其他G饿死。

  栈扩张：每一个G都有自己的栈空间，为了避免G过多导致使用过多的内存，一开始只会分配给G一块很小的栈空间，比如2k，当函数发现栈空间不足时，就会申请一块新的栈空间并把原来的栈内容复制过去，这就是G中_Gcopystack状态，64位机器最大是1GB，32位为256MB

* M：即machine，操作系统的线程，由操作系统的调度器调度和管理。每个线程有一个TLS（Thread-Local Storage），用于保存线程中的本地数据，用于获取系统线程中当前的G和G所属的M实例。

  * M的数量不一定和P匹配，可以设置多个M，M和P绑定后才可运行，多余的M会处于休眠状态；

  * 调度器最多可创建10000个M，但最多只有GOMAXPROCS个活跃线程能够正常运行，或者自旋；

    所以一般情况下，会设置与P一样数量的M，让所有的调度都发生在用户态，减少额外的调度和上下文切换开销；

  * M被创建的时机：当没有足够的M来关联P，并运行P中LRQ的G，或者所有的M都被阻塞住时，就回去空闲M链表中查找M，如果还没有，就会创建新的M；

* P：即processor，处理器的抽象，运行在线程上的本地调度器，用来管理和执行goroutine，使得goroutine在一个线程上跑，提供了线程需要的上下文，（局部计算资源，用于在同一线程写多个goroutine的切换），负责调度线程上的LRQ，是实现从N：1到N：M映射的关键。存在的意义在于工作窃取算法。

  * P的个数取决于**GOMAXPROCS**，默认使用CPU的个数，这些P会绑定到不同内核线程，尽量提升性能，让每个核都有代码在跑。在确定了P的最大数量n后，当程序运行时，创建n个P，P代表代表并发度；

  * P包含一个LRQ(Local Run Queue本地运行队列)，保存P需要执行的goroutine的队列。**LRQ是一个长度为256的环形数组**，有head和tail两个序号，当数量达到256时，新创建的goroutine会保存在GRQ中，LRQ中随机一半G也放到GRQ中；

    当在G0中产生G1，此时会G1会优先加入当前的LRQ队列，保证其在同一个M上执行；
    
  * P本身还会维护一个`local freelist G`用于复用G，类似池，在短时间内大量创建G且执行完成的时间很短时用处比较大；

* 全局运行队列GRQ（Global Run Queue）：由调度器本身持有，保存所有未分配的goroutine，保存在全局遍历sched中。GRQ是一个链表，由head，tail两个指针。

  在没有P的情况下，所有G只能放在一个GRQ(全局队列)中，当M执行完G，且没有G可执行时，必须锁住该全局队列才能取G。

* 空闲的M链表：主要用于保存无G可运行时而进入休眠的M，也保存在全局变量sched中，进入休眠的M会等待信号量m.park的唤醒。

* 空闲的P链表：当无G可运行时，拥有P的M会释放P并进入休眠状态，释放的P会变成空闲状态，加入到空闲的P链表中，也保存在全局变量sched中，当M被唤醒时，其持有的P也会重新进入运行状态。

> go中还有特殊的M和G, 它们是M0和G0.
>
> M0是启动程序后的主线程, 这个M对应的实例会在全局变量M0中, 不需要在heap上分配, 
> M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了.
>
> G0是仅用于负责调度的G, G0不指向任何可执行的函数, 每个M都会有一个自己的G0, 
> 在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0，其他G的栈扩容也是G0来执行。

## GPM三者的关系

* 持有P的M会执行G，执行完G后会先判断是否满足61次调用，如果是，则先从GRQ中获取，否则继续从P的LRQ中继续获取G进行消费；之所以先有次数判断，是为了防止GRQ里的G被饿死；

  当发现P的LRQ中没有其他G可执行时，则会从GRQ里获取G放入本地队列，获取数量`n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))`，一次不会获取太多，保证其他M在GRQ中有G可拿，**获取时会加锁**；

  当P发现自己的LRQ、GRQ都没有G了，则会随机从其他P的LRQ尾部中窃取一半的G放到自己的LRQ，通过CAS获取；（**work stealing 工作窃取**）

  如果LRQ、GRQ、其他P的LRQ都没有G时，会从netpuller(网络轮询器)上进行work stealing；

* 当P的LRQ满时，会把当前P的LRQ前一半的G打乱顺序后转移到GRQ；

* 当P的LRQ和调度器的GRQ都没有可执行的G时，M进入自旋状态；

  M进入自旋，是为了避免频繁的休眠和唤醒产生大量的开销，当其他G准备就绪时，首先被调度到自旋的M上，其次才是去创建新线程；

  自旋只会持续一段时间，如果自旋期间没有G需要调度，则之后会进入休眠状态，等待被唤醒；

  M自旋时会调用G0协程，G0协程主要负责调度时协程的切换；

  M是否新建取决于正在自旋的M或者休眠的M的数量；

* 当M执行的G发生阻塞时，将挂起当前M和G，从当前P中摘除，从空闲M链中唤醒一个M服务这个P，执行这个P的LRQ上的其他G；

  如果当前P的LRQ、调度器的GRQ上没有G，则P加入空闲P链表，等待M来获取可用的P；

  阻塞结束后，该M和G会尝试找回原来的P（有利于数据局部性），如果原来的P没空，则获取其他空闲的P，放入其LRQ，等待执行；如果没有空闲的P，则G放入GRQ，M继续休眠；（**hand off策略**）

* 运行时的G会尝试唤醒其他空闲的M和P进行组合，由于M和P由于刚被唤醒，进入自旋状态，G0发现P的本地队列没有G，则先去GRQ里进行working stealing，如果GRQ里没有，则去其他P的LRQ里working stealing；

这里有一个有趣的例子

```go
func main() {
    runtime.GOMAXPROCS(1)
    for i := 0; i < 10; i++ {
        i := i
        go func() {
            fmt.Println(i)
        }()
    }

    var ch = make(chan int)
    <- ch
}
// 输出的数是 9、0、1、2、3、4、5、6、7、8
原因是此时P=1，不涉及GRQ，for循环中产生的协程都会进到这个p里
由于此时还没发生调度，每次新产生的协程都会被M持有，这时就会把老的协程放到p的LRQ中，当i=9时，M持有i=9的协程，此时p的LRQ队列因为先进先出的缘故，持有的协程顺序是0，1，2，3，4，5，6，7，8
此时执行到读chan的语句，调度发生，main goroutine挂起，m运行持有的协程i=9，之后继续消费LRQ里的协程，因此输出顺序是 9、0、1、2、3、4、5、6、7、8
```

## 调度器的策略

* 复用线程，避免线程频繁的创建和销毁，使用work stealing机制和hand off机制
* 并行：`GOMAXPROCS`设置P的数量，最多有`GOMAXPROCS`个线程在CPU上同时运行或自旋
* 抢占：一个G最多运行10ms，还有sysmon协程协助式抢占，防止其他G被饿死

## 调度(抢占)的时机

* go调度器，本质是为需要执行的G寻找M以及P，不是一个实体，调度是需要发生调度时由M执行runtime.schedule方法进行；
* 函数调用期间，如G需要栈扩容，就会调度另一个G
* 调度器初始化时，会依次调用mcommoninit：初始化M资源池、procresize：初始化P资源池、newproc：G的运行现场和调度队列；
* channel、mutex等sync操作发生协程阻塞；
* time.sleep，go1.13以前的版本，会创建一个goroutine，专门用来唤醒挂载timer上的时间未到期的goroutine，但在1.14之后不会创建goroutine来做这件事，而是在调度循环的各个地方、sysmon中都有唤醒timer的代码，使得timer的唤醒更加及时；
* IO
* GC，如STW期间，P上执行safe point
* 运行过久，比如G每次只执行10ms，或系统调度过久

## 调度器的生命周期

![go调度器的生命周期](https://github.com/Nixum/Java-Note/raw/master/picture/go_调度器的生命周期.png)

## 总的调度流程

![goroutine schedule](https://github.com/Nixum/Java-Note/raw/master/picture/GMP模型整体调度.png)

5.1 当M执行某个G时发生syscall或其他阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除，然后再创建一个新的M（操作系统线程或者复用其他空闲线程）来服务这个P，即此时的M会直接管理阻塞的G，之前跟它绑定的P转移到其他M，执行其他G。

当原阻塞的M系统调用或阻塞结束时，其绑定的这个G要继续往下执行，会优先尝试获取之前的P，若之前的P已经跟其他M绑定，则尝试从空闲的P链表获取P，将G放入这个P的本地队列，继续执行。如果获取不到P，则该M进入休眠，加入休眠队列，G则放入全局队列，等其他P消费它。

### 调度Demo

单核机器，只有一个处理器P，系统初始化两个线程M0和M1，处理器P优先绑定线程M0，线程M1进入休眠状态。目前P正在处理G0，LRQ里的G1、G2、G3等待处理，GRQ里的G4、G5等到分配。

如果G0短时间处理完，P就会从LRQ取出G1进行处理，LRQ从GRQ取出G4进行分配；

![goroutine runtime_1](https://github.com/Nixum/Java-Note/raw/master/picture/go_goroutine_runtime1.png)

如果G0处理得很慢，系统就会让M0休眠，挂起G0，唤醒线程M1，将LRQ转移给M1进行处理；

如果此时G1也处理得很慢，此时会阻塞，或者休眠M1，唤醒M0，回去继续处理G0；**切换M和G的操作由sysmon协程进行处理，即抢占式由sysmon函数实现**。

如果G1处理得很快，则继续获取LRQ里的下一个G；待LRQ里的G都执行完了，切回M0，继续处理G0。

![goroutine runtime_2](https://github.com/Nixum/Java-Note/raw/master/picture/go_goroutine_runtime2.png)

如果是多核的，有多个P，多个M，当有一个P处理完所有的G后，会先从GRQ中获取G，如果获取不到，就会从另一个P的LRQ里取走一半G，继续处理。

## sysmon协程

**由sysmon协程进行协作式抢占**，对goroutine进行标记，执行goroutine时如果有标记就会让出CPU，对于syscall过久的P，会进行M和P的分配，防止P被占用过久影响调度。

![go sysmon goroutine](https://github.com/Nixum/Java-Note/raw/master/picture/go_sysmon_goroutine.png)

## M：Machine

M本质是一个循环调度，不断的执行schedule函数，查找可运行的G。会在自旋与休眠的状态间转换。

没有状态标记，只是会处于以下几个场景：

* 自旋：M正在从LRQ中获取G，此时M会拥有一个P
* 拥有一个P，执行G中的代码
* 进行系统调用或者G的阻塞操作，此时M会释放P
* 休眠，无G可执行，不拥有P，此时存在空闲线程队列

## G：Goroutine的状态

![go goroutine state](https://github.com/Nixum/Java-Note/raw/master/picture/go_goroutine_state.png)

goroutine的状态不止以下几种，只是这几种比较常用

| G状态       | 值     | 说明                                                         |
| ----------- | ------ | ------------------------------------------------------------ |
| _Gidle      | 0      | 刚刚被分配，还没被初始化                                     |
| _Grunnable  | 1      | 表示在runqueue上，即LRQ，还没有被执行，此时的G才能被M执行，进入Grunning状态 |
| _Grunning   | 2      | 执行中，不在runqueue上，与M、P绑定                           |
| _Gsyscall   | 3      | 在执行系统调用，没有执行go代码，没在runqueue上，只与M绑定，此时P转移到其他M中 |
| _Gwaiting   | 4      | 被阻塞（如IO、GC、chan阻塞、锁）不在runqueue，但一定在某个地方，比如channel中，锁排队中等 |
| _Gdead      | 6      | 现在没有在使用，也许执行完，或者在free list中，或者正在被初始化，可能有stack |
| _Gcopystack | 8      | 栈正在复制，此时没有go代码，也不在runqueue上，G正在获取一个新的栈的空间，并把原来的内容复制过去，防止GC扫描 |
| _Gscan      | 0x1000 | 与runnable、running、syscall、waiting等状态结合，表示GC正在扫描这个G的栈 |

## P：Processor的状态

![go processor state](https://github.com/Nixum/Java-Note/raw/master/picture/go_processor_state.png)

| 状态      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| _Pidle    | 空闲，无可运行的G，这时M拥有的P会加入空闲P队列中，LRQ为空    |
| _Prunning | 被线程 M 持有，并且正在执行G或者G0（即用户代码或者调度器逻辑） |
| _Psyscall | 用户代码触发了系统调用，此时P没有执行用户代码                |
| _Pgcstop  | 被线程 M 持有，且因gc触发了STW而停止                         |
| _Pdead    | 当运行时改变了P的数量时，多余的P会变成此状态                 |

## 泄露与排查

goroutine的泄露一般会导致内存的泄露，最终导致OOM，原因一般是该运行完成的goroutine一直在运行，没有结束，可能的原因是goroutine内阻塞，死循环。

检查工具：pprof，请求/debug/pprof/goroutine接口或者heap接口，判断内存占用走势，分析内存使用情况。一般的走势是整体向上递增，伴随一个一个的峰谷。

# 内存模型

> * mcache：P中的内存缓存，用于小对象（<=32KB）的内存分配，是堆的一部分；
> * mspan：是mheap管理内存最基本的结构，双向链表，保存起始页地址，span大小，span中页的数量；
> * mcentral：将相同大小的span聚合起来，每个mcentral包含两个mspan链表
> * mheap：用于大对象（>32KB）的内存分配，GC的主要地方
>
> 如果mcache有空闲的空间，那直接在mcache分配，如果没有，则尝试去mcentral中获取一个空闲的mspan，如果mcentral中也没有可用的mspan，则去mheap向操作系统申请可用的mspan。
> 
> ![](https://github.com/Nixum/Java-Note/raw/master/picture/go_mem_alloc_summary.png)

# 逃逸分析

之所以需要逃逸分析，是因为GC只清理堆内存，函数执行时内存分配在栈上，函数结束时栈内存会被回收，无需GC。

* go通过逃逸分析决定变量在堆上分配还是在栈上分配

  如果变量只在函数内被引用，则优先分配在栈上

  如果变量还在函数外被引用，则优先分配在堆上

* go中逃逸分析是在编译期完成

* go中逃逸分析只针对指针，一个值引用变量如果没有被取址，那它永远不可能逃逸

* 使用`go run -gcflags "-m -l"`命令运行时加入参数，-m表示打印逃逸分析信息，-l 表示禁止内联编译

## 逃逸场景

* 在函数内new出来或使用字面量创建的变量，其值作为函数的返回值，该变量一定发生逃逸；
* 被已经逃逸的变量引用的指针，也发生了逃逸；
* 被指针类型的slice、map和chan引用的指针一定发生了逃逸；
* 返回值为interface{}类型，由于编译期间无法判断是具体类型，也会发生逃逸；
* 栈空间不足时也会发生逃逸，对于64位机器，栈空间是8MB，使用`ulimit -a`命令查看机器上栈允许占用的内存大小；
* 闭包函数直接访问外部的变量；

# GC

## 基本

* 使用**可达性分析**判断对象是否被回收
* 三色标记法进行GC，本质是标记-清除算法，三色标记法是其改进版，主要是为了减少STW的时间
* Go 语言为了实现高性能的并发垃圾收集器，使用三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制将垃圾收集的暂停时间优化至毫秒级以下

## 使用三色标记法的原因

* Go运行时的内存分配算法基于 tcmalloc，基本没有碎片问题，对对象进行整理不会带来实质性的性能提升；
* Go的编译器会通过逃逸分析将大部分新生对象存储在栈上，而栈在方法结束后即可被回收，只有那些需要长期存在的对象才会被分配到堆中，goroutine死亡后，栈也可被直接回收，不需要GC参与，因此无需分代、频繁检查对象；
* Go的垃圾收集器与用户代码并发执行，使得STW的时间变短，STW的时间与对象的代际、对象的大小没有关系；

## 垃圾收集器标记过程中最先检查的对象，即GCRoot

* 全局变量：程序在编译期就能确定的存在于整个生命周期的变量；
* 执行栈：每个goroutine包含自己的执行栈，这些执行栈上包含栈上的变量以及指向分配的堆内存的指针；
* 寄存器：寄存器的值可能表示一个指针，这些指针可能指向某些赋值器分配的**堆内存区块**；

## 三色标记

* 白色：潜在垃圾，其内存可能会被垃圾收集器回收
* 灰色：活跃对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象
* 黑色：活跃对象，包括不存在任何引用外部指针对象以及从根对象可达的对象

![go gc简化过程](https://github.com/Nixum/Java-Note/raw/master/picture/go_gc.gif)

1. 初始对象都是白色，首先把所有对象都放到白色集合中
2. 从根节点开始遍历对象，遍历到的对象标记为灰色，并从白色集合放入到灰色集合
3. 遍历灰色对象，把自己标记为黑色，放入黑色集合，将其引用的对象标记为灰色，放入灰色集合
4. 重复第3步，直到灰色集合为空，此时所有可达对象都被标记，标记阶段完成
5. 清除阶段开始，白色集合里的对象为不可达对象，即垃圾，对内存进行迭代清扫，回收白色对象
6. 重置GC状态，将所有的对象放入白色集合中

> 实际上并没有对应颜色的集合，对象被内存分配器分配在span中，span里有个gcmarkBits字段，每个bit代表一个slot被标记，白色对象该bit为0，灰色或黑色为1。
>
> 每个p中都有wbBuf和gcw gcWork, 以及全局的workbuf标记队列, 实现生产者-消费者模型, 在这些队列中的指针为灰色对象, 表示已标记, 待扫描.
>
> 从队列中取出来并把其引用对象入队的为黑色对象, 表示已标记, 已扫描. (runtime.scanobject).

## 写屏障

在go的早期版本中，在标记阶段时，因为用户程序可能会修改对象的指针，导致标记错误，对象被错误回收，因此在标记阶段需要STW。

之后的版本里，为了减少STW时间，需要进行并发标记，因此需要写屏障来保证标记的正确性

> 想要在并发或增量的标记算法中保证正确性，需要达成**任意**一种三色不变性
>
> * 强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或黑色对象
> * 弱三色不变性：黑色对象可以指向白色对象，但是该白色对象必须有被其他灰色对象直接或间接引用

go中使用了写屏障是在写入指针前执行的一小段代码，用以防止并发标记时指针丢失，这一小段代码Go是在编译时加入的。

### Dijkstra的插入写屏障 - 灰色赋值器

在标记阶段，在对对象所引用的指针进行修改时触发，比如A引用了B，在标记阶段，A将对B的引用改成了C，C会被标记为灰色。go会在堆区使用插入写屏障。

优点：可以立即开始并发标记

缺点：相对保守，部分残留对象只能留在下一次进行回收；另外，插入写屏障有两种实现方式：

	1. 在标记阶段，如果每次有指针赋值操作都需要引入写屏障，性能开销比较大；
	2. 因此在标记阶段，go只会对堆区中修改指针的操作启用写屏障，栈区中则不触发，在标记阶段结束时，需要STW重新扫描一遍栈区，直至没有灰色节点（避免黑指向白，因此新对象被黑指向之前，会变成灰色），停止STW，进行GC；

> ![go dijkstra插入写屏障](https://github.com/Nixum/Java-Note/raw/master/picture/go_dijkstra_插入写屏障.png)
>

> Dijkstra写屏障是对被写入的指针进行grey操作, 不能防止指针从heap被隐藏到黑色的栈中, 需要STW重扫描栈.

### Yuasa的删除写屏障 - 黑色赋值器

在标记阶段，对对象所引用的指针进行删除时触发，比如A引用了B，标记阶段，A取消了对B的引用，B会被标记为灰色。go会在栈区和堆区都使用删除写屏障

优点：标记结束时不需要STW；

缺点：已经被垃圾回收器扫描过，不会再次对其进行扫描，回收精度低；GC开始时STW扫描栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，用于把原来指向的对象标记为灰色；

> Yuasa写屏障是对将被覆盖的指针进行grey操作, 不能防止指针从栈被隐藏到黑色的heap对象中, 需要在GC开始时保存栈的快照.

![go yuasa删除写屏障](https://github.com/Nixum/Java-Note/raw/master/picture/go_yuasa_删除写屏障.png)

## 混合屏障

- GC 开始将栈上的对象全部扫描并标记为黑色（之后不再进行第二次重复扫描，无需STW）；
- GC 期间，任何在栈上创建的新对象，均为黑色；
- 被删除的堆对象标记为灰色；
- 被添加的堆对象标记为灰色；

混合屏障结合了删除写屏障和插入写屏障的优点，满足弱三色不变式，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行重新扫描，减少了STW的时间。

## GC触发条件

> 1. 内存大小阈值， 内存达到上次GC后的2倍
> 2. 达到定时时间 ，2min
> 3. runtime主动触发
>
> 阈值是由一个gc percent的变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。

## 垃圾收集过程

> 1. 清理终止阶段：
>    1. **暂停程序**STW，所有的goroutine在这时会进入安全点（Safe point）；
>    2. 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
> 2. 标记阶段：
>    1. 将状态切换至 `_GCmark`、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；占用25%CPU。
>    2. **恢复程序**，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
>    3. 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
>    4. 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
>    5. 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
> 3. 标记终止阶段：
>    1. **暂停程序STW**、将状态切换至 `_GCmarktermination` 并停止写屏障，关闭辅助标记的用户程序；
>    2. 清理处理器上的线程缓存；
> 4. 清理阶段；
>    1. 将状态切换至 `_GCoff` 开始清理阶段，初始化清理状态并关闭写屏障；
>    2. 恢复用户程序，所有新创建的对象会标记成白色；
>    3. 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；
>
> 并发垃圾回收是先STW找到所有的Root对象，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，再次扫描和标记，以免释放使用中的内存。

## 关注的指标

* CPU利用率
* GC停顿时间
* GC停顿频率
* GC可扩展性

## GC性能优化技巧

* slice预先分配内存，因为slice扩容时会返回新的slice，如果频繁扩容会增加GC压力；
* map的key和value使用值类型，而不是指针类型，利用map中extra中的特性；
* go中，string底层也是指针，如果string不可变，可以在转成 byte数组，这样就不会生成原有变量的副本，新的变量共享底层的数据指针。此特性也可用在把字符串转成[]byte，再作为map的key或value；
* 对于占用空间少，频繁分配的函数，函数返回值使用值类型，不使用指针类型，因为返回指针类型会带来指针逃逸，使得原来可以分配在栈上的内存分配在堆上。在栈上进行小对象拷贝的性能会比对象在堆上分配好得多；
* 对象如果包含了指针，则需要递归进行扫描，大量使用对象真正会使垃圾回收耗时变长；
* 减少频繁创建goroutine，可以的话是一批一批的创建

# 参考

[图解Go协程调度原理，小白都能理解 ](https://www.cnblogs.com/secondtonone1/p/11803961.html)

[深入golang runtime的调度](https://zboya.github.io/post/go_scheduler)

[gopher meetup-深入浅出Golang Runtime-yifhao](https://www.lanzous.com/i7lj0he)

[Golang调度器GMP原理](https://studygolang.com/articles/27069?fr=sidebar)

[【golang】GMP调度详解](https://segmentfault.com/a/1190000023869478)

[GC](https://qcrao91.gitbook.io/go/gc/gc)

[Golang垃圾回收(GC)介绍](https://liangyaopei.github.io/2021/01/02/golang-gc-intro/)

[Golang三色标记+混合写屏障模式全分析](https://www.kancloud.cn/aceld/golang/1958308)

[垃圾回收](https://go.xargin.com/docs/runtime/memory_management/garbage_collection/)

[goroutine原理|YouSec](https://yousec995.github.io/2021/07/25/Goroutine%E5%8E%9F%E7%90%86/)
